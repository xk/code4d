  //@use:  // $err := FILE_Get_Path_Parent ($Par_1:ptr ;$Par_2:txt ; {$Par_3:long})If (False)  //=================  //@FUNCTION: FILE_Get_Path_Parent  //@brief: Returns parent of specified path  //  //=================  //@params:  //$1 is full path to extract parent from  //@returns:  //$0 is parent of specified path  //   = NULL if path invalid or already root  //  //   NOTE: Platform dependant  //@todo:  // To be rewritten with Regex  //=================  //@author: jpupier  //@modified_by:  //---------  //@version: 1.0  //@date: 22 oct, 2010  //=================  //@SVN_Folder: MH_/Else   //=================C_TEXT($ParentPath_t;$0)$ParentPath_t:=""C_TEXT($1;$FullPath_t)$FullPath_t:=$1  //------------------------------------------------------------C_LONGINT($DirectorySymbol_l)  //directory symbol$DirectorySymbol_l:=Character code(Folder separator)C_LONGINT($FullPathLength_l)  //length of path to scan$FullPathLength_l:=Length($FullPath_t)  //------------------------------------------------------------C_LONGINT($Loop_l)C_LONGINT($DelimiterIndex_l)  //============================================================  //init$DelimiterIndex_l:=0  //------------------------------------------------------------End if   //============================================================  //make sure path has something to scanIf ($FullPathLength_l>1)  //loop backwards through bytes in path (do not check last byte)For ($Loop_l;$FullPathLength_l-1;1;-1)  //check if directory symbolIf (Character code($FullPath_t[[$Loop_l]])=$DirectorySymbol_l)$DelimiterIndex_l:=$Loop_l$Loop_l:=1  //get out of loopEnd if End for End if   //  //check if directory delimter foundIf ($DelimiterIndex_l#0)  //extract parent path  $ParentPath_t:=Substring($FullPath_t;1;$DelimiterIndex_l)End if   //============================================================$0:=$ParentPath_t  //eof