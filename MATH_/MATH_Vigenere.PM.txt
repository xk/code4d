If (False)  // MATH_Vigenere [Antoine Galmiche 15/09/2005]  // ------------------------------------------------------  // ---------------   F R A N C A I S  ---------------  // ------------------------------------------------------  // Cryptage polyalphabétique d'une chaine suivant une clef.  // Suivant la grille de Blaise de Vigenère  // Si nécessaire, la clef est répétée pour être à la longueur du texte à chiffrer.  // Plus la clef est longue, plus le chiffre est solide.  // Seuls les caractères alphabétiques de A à Z sont codés,  // les autres engendrent une erreur.  // ---------------------------------------------  // MATH_Vigenere (Entier;Clef;Texte) -> Texte Résultat  // Entier est un sélecteur : 1=chiffrer, 2=déchiffrer  // Clef est un texte, si possible plus court que le texte à coder  // Texte est soit le texte clair, soit le texte codé  // Le résultat est soit le texte codé, soit le texte clair.  // ---------------------------------------------  // MATHERROR  // 0 -> Pas d'erreur  // -1 -> Caractères interdits  // -2 -> Mauvais sélecteur  // -3 -> Clef ou texte vides  // ------------------------------------------------------  // ---------------   E N G L I S H   -----------------  // ------------------------------------------------------  // Polyalphabetic encryption of a string with a key according to Blaise de Vigenère grid  // If necessary, key is repeated to reach lenght of text to cipher  // The longer is the key, the strongest is encryption.  // Only alphabetic characters from A to Z are coded, others give an error  // ---------------------------------------------  // MATH_Vigenere (Integer;Key;Text) -> Result text  // Integer is a selector : 1=cipher, 2=decipher  // Key is string, if possible shorter than text to cipher  // Text is unciphered or ciphered text  // Result is ciphered or unciphered text.  // ---------------------------------------------  // MATHERROR  //   0 -> No error  // -1 -> Forbidden characters  // -2 -> Bad selector  // -3 -> Empty key or text  // ---------------------------------------------  //  (translation : BE 3-2010)End if   //@SVN_Folder: MATH_/C_LONGINT($1)  // sélecteur 1=chiffrer, 2=déchiffrerC_TEXT($2;$3;$0)  // clef; texte à travailler; résultatC_TEXT($txtclef;$txt;$txtres)MATHERROR:=0$txtclef:=$2$txt:=$3$0:=""Case of : (($txtclef="") | ($txt=""))MATHERROR:=-3: (($1<1) | ($1>2))MATHERROR:=-2Else If (Length($txtclef)>Length($txt))$txtclef:=Substring($txtclef;1;Length($txt))End if For ($i;1;Length($txt))$car:=$txt[[$i]]If (((Character code($car)>=65) & (Character code($car)<=90)) | ((Character code($car)>=97) & (Character code($car)<=122)))$carclef:=$txtclef[[(($i-1)%Length($txtclef))+1]]$k:=Character code($carclef)If ($k>=97)$k:=$k-32End if $k:=$k-65  // numéro de ligne (décalage de l'alphabet)    $j:=Character code($car)If ($j>=97)  // on ne va travailler qu'en majuscules$j:=$j-32End if $j:=$j-65  // numéro de colonne    Case of : ($1=1)  // chiffrer         $0:=$0+Char(65+(($j+$k)%26)): ($1=2)  // déchiffrer       $0:=$0+Char(65+((26-$k+$j)%26))End case Else   // caractere hors champ -> on sort et on arrète toutMATHERROR:=-1$0:=""$i:=Length($txt)End if End for End case 