If (False)  //MATH_Combinatoire   //Auteur : Bernard Escaich   //Date : 27/09/03,03/10/03  // ------------------------------------------------------  // ---------------   F R A N C A I S  ---------------  // ------------------------------------------------------  //Cette méthode recherche dans le tableau de valeurs passé en paramètre 2 la combinaison dont le total est égal au nombre passé en paramètre 1  //Le tableau de booléens indique à la méthode appelante les valeurs retenues  //Le système s'arrète à la première combinaison trouvée  // ATTENTION : nécessite MATH_LongVersBinaire  // MATH_Combinatoire (Nombre; PtrRéels; PtrBooléens)  // Nombre (Réel) Nombre initial  // PtrRéels (Pointeur tableau réels) Tableau contenant les valeurs possibles  // PtrBooléens (Pointeur tableau booléens) Tableau contenant la combinaison  // ---------------------------------------------  // MATHERROR  // 0 -> Pas d'erreur  // ------------------------------------------------------  // ---------------   E N G L I S H   -----------------  // ------------------------------------------------------  // This method looks in array passed as parameter 2, for for combination of values whose sum is equal to value passed as parameter 1  //Boolean array points out chosen values to calling method  //Search stops when first combination is founded.  //WARNING : needs MATH_LongVersBinaire  // MATH_Combinatoire (Number; PtrReals; PtrBoolans)  // Number (Real) : Value to find  // PtrReals (Pointer on real array) Array with values to search  // PtrBoolans (Pointer on boolean array) Array pointing out values selected  // ---------------------------------------------  // MATHERROR  //  0 -> No error  // ------------------------------------------------------  //  (translation : BE 03-2010)End if   //@SVN_Folder: MATH_/C_LONGINT(MATHERROR)MATHERROR:=0C_REAL($1)  //nombre à chercherC_POINTER($2)  //tableau de valeursC_POINTER($3)  //tableau de booléens  //_________________________________________________________________________C_BOOLEAN($vb_OK)C_REAL($vr_Montant;$vr_Montant_Calculé)C_LONGINT($i;$j;$vl_Limite_Boucle;$vl_Nombre_Essais)C_TEXT($vt_Matrice)$vb_OK:=True$vr_Montant:=$1  //Le point de départ est le nombre à chercher augmenté de la déviation maximale$vl_Limite_Boucle:=2^(Size of array($2->))For ($i;1;$vl_Limite_Boucle)$vt_Matrice:=MATH_LongVersBinaire ($i)$vr_Montant_Calculé:=0For ($j;1;Size of array($2->))If ($vt_Matrice[[$j]]="1")$vr_Montant_Calculé:=$vr_Montant_Calculé+$2->{$j}End if Case of : ($vr_Montant_Calculé=$vr_Montant)$vl_Nombre_Essais:=$i$i:=MAXLONG-1$j:=MAXLONG-1: ($vr_Montant_Calculé<$vr_Montant) & ($j=Size of array($2->))$j:=MAXLONG-1End case End for End for   //Sélectionner les enregistrements trouvés par le tableau de booléens  // associé aux montantsFor ($i;1;Size of array($2->))If ($vt_Matrice[[$i]]="1")$3->{$i}:=TrueEnd if End for 