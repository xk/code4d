If (False)  // MATH_NTF_SexaVersLambert [Marc Duc-Jacquet, Antoine Galmiche 05/2007]  // d'après Serge Milles  // ------------------------------------------------------   // ---------------   F R A N C A I S  ---------------  // ------------------------------------------------------  // Conversion données  //  $1,$2,$3,$4 pointeurs sur des réels   $1,$2  pour  lat long  de la source  // $3,$4 pour lat long de la cible . Ces quantités sont en DD et signées:  //  latitude (>0 si N, <0 si S) et longitude ( >0 si E, <0 si W)  // $3 et $4 lat et long cible sont également signées  // ---------------------------------------------  // MATH_NTF_SexaVersLambert (->NTF_Lat;->NTF_Long;->LAMB_X;->LAMB_Y)  // ---------------------------------------------  // MATHERROR  // 0 -> Pas d'erreur  // ------------------------------------------------------  // ---------------   E N G L I S H   -----------------  // ------------------------------------------------------  // Data conversion    //  $1,$2,$3,$4 pointers on reals     // $1,$2  for  latitude and longitude of source  // $3,$4 for  latitude and longitude of target .   // Those values are in DD and signed  //  latitude (>0 if N, <0 if S) and longitude ( >0 if E, <0 if W)  // $3 et $4 latitude and longitude of target are also signed  // ---------------------------------------------  // MATH_NTF_SexaVersLambert (->NTF_Lat;->NTF_Long;->LAMB_X;->LAMB_Y)  // ---------------------------------------------  // MATHERROR  // 0 -> No error  // ---------------------------------------------  //  (translation : BE 03-2010)End if   //@SVN_Folder: MATH_/C_LONGINT(MATHERROR)MATHERROR:=0C_POINTER($1;$2;$3;$4)C_REAL($Source_Lat;$Source_Long;$Lamb_EE_Arr;$Lamb_NN_Arr)C_REAL($Lamb_a;$Lamb_b;$Lamb_Phi0;$Lamb_Lambda0;$Lamb_e;$Lamb_v;$Lamb_v0)C_REAL($Lamb_LatIso;$Lamb_Gamme;$Lamb_Ce;$Lamb_Cn;$Lamb_R0;$Lamb_Phi1;$Lamb_Phi2)C_REAL($Lamb_v01;$Lamb_v02;$Lamb_Ro01;$Lamb_Ro02;$Lamb_m1;$Lamb_m2;$Lamb_mL;$Lamb_mLR0)C_REAL($Lamb_R;$Lamb_E1;$Lamb_EE;$Lamb_NN)C_REAL($un;$deux)  //lecture source  en DD$Source_Lat:=($1->)$Source_Long:=($2->)  // Constantes Ellipsoïde Hayford $Lamb_a:=MATH_ConstantesGéodésiques ("Clarke_a")$Lamb_b:=MATH_ConstantesGéodésiques ("Clarke_b")  // 6356515$Lamb_Phi0:=46,8$Lamb_Lambda0:=2,596921296/200*180$Lamb_e:=(Square root(($Lamb_a^2)-($Lamb_b^2)))/$Lamb_a  //Lamb_v = Lamb_a / (racine (1 - Lamb_e^2 * (sin(Phi * PI/180)^2))  //$un:=($Lamb_e^2)(Sin($Source_Lat*Pi /180)^2)  `BE : ERREUR COMPIL -> neutralisé$Lamb_v:=$Lamb_a/Square root(1-$un)  // Lamb_LatIso = Lamb_LatIso = Ln(tan(Pi/4+Phi/2))-e/2*Ln((1+e*sin(Phi))/(1-e*sin(Phi)))$un:=Log(Tan(Pi/4+($Source_Lat*Pi/360)))$deux:=$Lamb_e*Sin($Source_Lat*Pi/180)+1$deux:=$deux/(1-($Lamb_e*Sin($Source_Lat*Pi/180)))$Lamb_LatIso:=$un-($Lamb_e/2*Log($deux))  //Latitude isométrique -Lamb_LatIso0 = Ln(tan(Pi/4+Phi0/2))-e/2*Ln((1+e*sin(Phi0))/(1-e*sin(Phi0))) $un:=Log(Tan(Pi/4+($Lamb_Phi0*Pi/360)))$deux:=1+($Lamb_e*Sin($Lamb_Phi0*Pi/180))$deux:=$deux/(1-($Lamb_e*Sin($Lamb_Phi0*Pi/180)))$Lamb_LatIso0:=$un-($Lamb_e/2*Log($deux))If ($Source_Long<180)$Lamb_Gamma:=($Source_Long-$Lamb_Lambda0)*Sin($Lamb_Phi0*Pi/180)End if If ($Source_Long>180)$Lamb_Gamma:=($Source_Long-$Lamb_Lambda0-360)*Sin($Lamb_Phi0*Pi/180)End if   //Constantes de Zone Lambert II en km$Lamb_Ce:=600$Lamb_Cn:=2200  //Lamb_a / (racine(1 - Lamb_e^2) * (sin (Lamb_Phi0 * pi/ 180))^2)$un:=($Lamb_e^2)*(Sin($Lamb_Phi0*Pi/180)^2)$un:=Square root(1-$un)$Lamb_v0:=$Lamb_a/$un$Lamb_R0:=$Lamb_v0/Tan($Lamb_Phi0*Pi/180)$Lamb_Phi1:=50,99879884/200*180$Lamb_Phi2:=52,99557167/200*180  //Lamb_v01 = Lamb_a / (Math.sqrt(1 - Math.pow (Lamb_e,2) * Math.pow(Math.sin (Lamb_Phi1 * Math.PI / 180),2)))$un:=($Lamb_e^2)*(Sin($Lamb_Phi1*Pi/180)^2)$Lamb_v01:=$Lamb_a/(Square root(1-$un))  //Lamb_v02 = Lamb_a / (Math.sqrt(1 - Math.pow (Lamb_e,2) * Math.pow(Math.sin (Lamb_Phi2 * Math.PI / 180),2)))$un:=($Lamb_e^2)*(Sin($Lamb_Phi2*Pi/180)^2)$Lamb_v02:=$Lamb_a/(Square root(1-$un))  //$Lamb_Ro01=Lamb_a * (1 - Math.pow (Lamb_e,2)) / Math.pow((Math.sqrt(1 - Math.pow (Lamb_e,2) * Math.pow(Math.sin (Lamb_Phi1 * Math.PI / 180),2))),3)$un:=($Lamb_e^2)*(Sin($Lamb_Phi1*Pi/180)^2)$un:=Square root(1-$un)$un:=($un^3)$Lamb_Ro01:=$Lamb_a*(1-($Lamb_e^2))/$un$un:=($Lamb_e^2)*(Sin($Lamb_Phi2*Pi/180)^2)$un:=Square root(1-$un)$un:=($un^3)$Lamb_Ro02:=$Lamb_a*(1-($Lamb_e^2))/$un  //Lamb_m1 = 1 + Lamb_Ro01 / 2 / Lamb_v01 * Math.pow((Lamb_Phi1 - Lamb_Phi0) * Math.PI / 180,2)$un:=$Lamb_Ro01/2/$Lamb_v01*(($Lamb_Phi1-$Lamb_Phi0)*Pi/180^2)$Lamb_m1:=1+$un  //Lamb_m2 = 1 + Lamb_Ro02 / 2 / Lamb_v02 * Math.pow((Lamb_Phi2 - Lamb_Phi0) * Math.PI / 180,2)$un:=$Lamb_Ro02/2/$Lamb_v02*(($Lamb_Phi2-$Lamb_Phi0)*Pi/180^2)$Lamb_m2:=1+$un$Lamb_m:=($Lamb_m1+$Lamb_m2)/2$Lamb_mL:=2-$Lamb_m$Lamb_mLR0:=$Lamb_mL*$Lamb_R0  //Lamb_R = Lamb_mLR0 * Math.exp(- Math.sin(Lamb_Phi0 * Math.PI / 180) * (Lamb_LatIso - Lamb_LatIso0))$un:=Sin($Lamb_Phi0*Pi/180)*($Lamb_LatIso-$Lamb_LatIso0)$Lamb_R:=$Lamb_mLR0*Exp(-$un)$Lamb_E1:=$Lamb_R*Sin($Lamb_Gamma*Pi/180)  // Coordonnées Lambert II du point$Lamb_EE:=$Lamb_E1+($Lamb_Ce*1000)$Lamb_NN:=$Lamb_mLR0-$Lamb_R+($Lamb_E1*Tan($Lamb_Gamma*Pi/360))+($Lamb_Cn*1000)  //Arrondis des valeurs  //$Lamb_EE_Arr:=Ent($Lamb_EE*1000)/1000  //$Lamb_NN_Arr:=Ent($Lamb_NN*1000)/1000  //SORTIES (signées) en mètres$3->:=$Lamb_EE  // X$4->:=$Lamb_NN  // Y