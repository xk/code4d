C_LONGINT($1)C_POINTER($2;$3)C_REAL($0)$0:=MTH_GMY_GraphArea ($1;$2;$3)  `TestéeIf (False)  ` MATH_SurfaceGraphe [Antoine Galmiche 07/2002, Marc Duc-Jacquet 10/2002]  ` ------------------------------------------------------  ` ---------------   F R A N C A I S  ---------------  ` ------------------------------------------------------   ` Rappels mathématiques :  ` Aire algébrique située entre l'axe Ox et une fonction linéaire par morceaux:  ` Soient a=X1 <X2<X3 ........ <Xn  , n abscisses  ` et Y1,Y2,Y3, .... Yn  les ordonnées correspondantes    ` Surface=1/2 *Somme [ (Xi+1-Xi) * ( Yi+1 - Yi ) ]   i=1,2,... N-1  ` ---------------------------------------------  ` MATH_SurfaceGraphe (sélecteur; ->TableauOrdonnées; ->Tableau2 ) -> Numérique  ` sélecteur (entier long) 1=Tableau2 contient les abscisses  `                                    2=Tableau2 contient 2 lignes : Origine et Pa  ` ou constantes Graphe_Abscisses et Graphe_Origine  ` TableauOrdonnées (Pointeur) Pointeur tableau réel des ordonnées  ` Tableau2 (Pointeur) Pointeur tableau réel , abscisses ou origine/pas  ` Résultat (Numérique) Surface de l'axe OX à la courbe  ` ---------------------------------------------  ` MATHERROR  `   0 -> Pas d'erreur  ` -1 -> Tableaux de tailles différentes ou taille<2  ` -2 -> Les abscisses ne sont pas distinctes ou bien ne sont pas croissantes  ` -3 -> Pas inférieur ou égal à 0  ` -4 -> Sélecteur non valable  ` -5 -> Tableau Origine/Pas non conforme  ` ------------------------------------------------------  ` ---------------   E N G L I S H   -----------------  ` ------------------------------------------------------  ` Math's summary :  ` Algbraic surface between Ox axis and a linear function by segments :  ` Said a=X1 <X2<X3 ........ <Xn  , n abscissas  ` et Y1,Y2,Y3, .... Yn  corresponding ordinates  ` Surface =1/2 *Sum [ (Xi+1-Xi) * ( Yi+1 - Yi ) ]   i=1,2,... N-1  ` ---------------------------------------------  ` MATH_SurfaceGraphe (selector; ->ArrayOrdinates; ->Array2 ) -> Real  ` Selector (longinteger) 1=Array2 contains abscissas  `                                         2=Array2 contains 2 lines : Origin and Step  ` or constants Graph_Abscissas et Graph_Origin  ` ArrayOrdinates (Pointer) Pointer on real ordinates array   ` Array2 (Pointer) Pointer real array, abscissas or origin/step  ` Result (Real) Surface from OX axis to the curv  ` ---------------------------------------------  ` MATHERROR  `   0 -> No error  ` -1 -> Arrays with different length or length <=2  ` -2 -> Abscissas are not distinct or increasing  ` -3 -> Step smaller or equal to zero  ` -4 -> Unvalid selector  ` -5 -> Array Origin/step unvalid  ` ---------------------------------------------  `  (translation : BE 03-2010)  `End if C_LONGINT(MATHERROR)C_LONGINT($1)C_POINTER($2;$3)C_REAL($0)$0:=0MATHERROR:=0C_REAL($n;$origine;$pas;$Y1;$X2;$Y2)C_LONGINT($i)  ` Traitement des erreursCase of : ($1=1)  ` Abscisses$n:=Size of array($2->)If ($n#Size of array($3->))  `test tableaux de même tailleMATHERROR:=-1Else If ($n<2)  `test tableaux de taille<2MATHERROR:=-1Else For ($i;2;$n)  `test abscisses croissantesIf (($3->{$i})>($3->{$i-1}))Else MATHERROR:=-2$i:=$nEnd if End for End if End if : ($1=2)  ` Origine et pasIf (Size of array($3->)#2)MATHERROR:=-5Else $origine:=$3->{1}$pas:=$3->{2}If ($pas<=0)MATHERROR:=-3End if End if Else MATHERROR:=-4  ` mauvais sélecteur    End case   ` AlgorithmeIf (MATHERROR=0)If ($1=1)$0:=($3->{2}-$3->{1})/2*$2->{1}  `terme (X2-X1)/2*Y1For ($i;2;$n-1)$0:=$0+(($3->{$i+1}-$3->{$i-1})/2*$2->{$i})  `terme (Xi+1-Xi-1)/2* YiEnd for $0:=$0+(($3->{$n}-$3->{$n-1})/2*$2->{$n})  `terme (XN-XN-1)*YN/2Else For ($i;1;(Size of array($2->)-1))$Y1:=$2->{$i}  ` ordonnée du 1ier point$X2:=$origine+$pas  ` abscisse 2eme point$Y2:=$2->{$i+1}  ` ordonnée 2eme pointIf ($Y1<$Y2)$0:=$0+($Y1*Abs($X2-$origine))+Abs(($X2-$origine)*($Y2-$Y1)/2)  ` surface rectangle axe + surface triangle têteElse $0:=$0+($Y2*Abs($X2-$origine))+Abs(($X2-$origine)*($Y2-$Y1)/2)End if $origine:=$X2End for End if End if End if 