If (False)  // MATH_Dichotomie [ Marc DUC-JACQUET 10/02 ]  // ------------------------------------------------------  // ---------------   F R A N C A I S  ---------------  // ------------------------------------------------------  //ATTENTION : nécessite MATH_Evaluation  //-------------------------------------------------  // RAPPELS MATHEMATIQUES :  // F(x) est continue sur (a,b)  // La méthode de dichotomie pour trouver un zéro de F(x) sur (a,b) consiste  //  à couper l'intervalle en 2 et repérer dans quel sous-intervalle est la racine  //  puis à itérer le processus  //-------------------------------------------------  // MATH_Dichotomie (F;A;B;NITERMAX;PREC;TOL;PtrTab)-->Réel  // F (texte) expression de la fonction F(x) avec le langage de 4D  // A et B (réels avec A<B)  localisation initiale d'un zéro de F  // NITERMAX(entier) : nombre maximum d'itérations   // si  [XG, XD] ( XG<=XD )   est la localisation finale d'un zéro de F  //  l'exécution est  dite normale si abs(XD-XG)<= PREC (réel)  //  l'exécution est arrêtée si abs(F(XD)*F(XG)) <= TOL (réel)  //  PtrTab ( pointeur) Pointeur sur le tableau TabR des résultats  //   TabR{1} = XG  et TabR{2} = XD    //   TabR{3} = nombre d'itérations réellement effectuées  // ---------------------------------------------  // MATHERROR:  renvoyé par la fonction  //              0   exécution normale : abs(XD-XG)<= PREC  //             -1   arrêt de niveau 1: abs(F(XD)*F(XG)) <= TOL  //             -2   arrêt de niveau 2: nombre max d'itérations atteint  //             -3   arrêt de niveau 3: données incorrectes A>B ou F(A)*F(B)>0  // ------------------------------------------------------  // ---------------   E N G L I S H   -----------------  // ------------------------------------------------------  // WARNING : MATH_Evaluation is needed  //-------------------------------------------------  // Math's summary  // F(x) is continuous over (a,b)  // Dichotomy method to find a solution of F(x) over (a,b) is to cut the interval in two,  // locate the sub-interval the solution is in, and repeat the process  //-------------------------------------------------  // MATH_Dichotomie (F;A;B;NITERMAX;PREC;TOL;PtrTab)-->Real  // F (text) F(x) function with 4D's language  // A and B (reals with A<B) initial location for an F solution  // NITERMAX (integer) maximum number of iterations  // if [XG, XD] (XG<=XD) is the initial location of an F solution  // running is normal if abs(XD-XG) <= PREC (real)  // running is stopped if abs(F(XD)*F(XG)) <= TOL (real)  // PtrTab (pointer) Pointer referencing the array TabR of real results  // TabR{1} = XG and TabR{2} = XD  // TabR{3} = number of iterations really done  // ---------------------------------------------  // MATHERROR:  returned by the function  //              0   normal running : abs(XD-XG)<= PREC  //             -1   stop level 1: abs(F(XD)*F(XG)) <= TOL  //             -2   stop level 2: max number of iterations has benn reached  //             -3   stop level 3: wrong data A>B or F(A)*F(B)>0  // ------------------------------------------------------  // (translation : AG - 03/2007)End if   //@SVN_Folder: MATH_/C_LONGINT(MATHERROR)C_TEXT($1)C_REAL($2;$3;$5;$6;$PREC;$TOL)C_LONGINT($0;$4;$NITER)C_POINTER($7)$INDIC:=-2$NITER:=0$NITERMAX:=$4$PREC:=$5$TOL:=$6$XG:=$2$XD:=$3$FXG:=MATH_Evaluation ($1;$XG)$FXD:=MATH_Evaluation ($1;$XD)If ($XG>$XD) | (($FXG*$FXD)>0)$INDIC:=-3Else While ($NITER<$NITERMAX) & ($INDIC=-2)$NITER:=$NITER+1$T:=($XG+$XD)/2$FT:=MATH_Evaluation ($1;$T)If ($FXG*$FT<0)$XD:=$T$FXD:=$FTElse $XG:=$T$FXG:=$FTEnd if If (Abs($XD-$XG)<=$PREC)$INDIC:=0End if If (Abs($FXG*$FXD)<$TOL)$INDIC:=-1End if End while End if $7->{1}:=$XG$7->{2}:=$XD$7->{3}:=$NITER$0:=$INDICMATHERROR:=$0