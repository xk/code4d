  `This method is part from Math4D project 2002-2010 with authors : Jacques Bossy, Philip Burns, Olivier Deschanels, Marc Duc-Jacquet  `Bernard Escaich, Antoine Galmiche, Micaël Germann, George F. Huhn, Nicolas Jore, Teddy Linet, Frédéric Quoirez, Michel Saiz, Robert Van LooIf (False)  ` MATH_Datum [Marc Duc-Jacquet, Antoine Galmiche 05/2007]  ` ------------------------------------------------------  ` ---------------   E N G L I S H   -----------------  ` ------------------------------------------------------  ` ATTENTION  ` Utilise MTH_GDY_Constants  ` ---------------------------------------------  ` Conversion between geodesic systems  ` ---------------------------------------------  ` MATH_Datum (TypeConversion; ->LatitudeSource; ->LongitudeSource; ->LatitudeTarget; ->LongitudeTarget)  ` TypeConversion (Chaine) Description of conversion type  ` LatitudeSource (Pointer)   ` LongitudeSource (Pointer)  ` LatitudeTarget (Pointer)   ` LongitudeTarget (Pointer)  ` ---------------------------------------------  ` MATHERROR  `   0 -> No error  ` -1 -> TypeConversion unknown  ` ------------------------------------------------------  ` ---------------   F R A N C A I S  ---------------  ` ------------------------------------------------------  ` ATTENTION  ` Utilise MTH_GDY_Constants  ` ---------------------------------------------  ` Conversion intersystèmes géodésiques  ` ---------------------------------------------  ` MATH_Datum (TypeConversion; ->LatitudeSource; ->LongitudeSource; ->LatitudeCible; ->LongitudeCible)  ` TypeConversion (Chaine) Description du type de conversion  ` LatitudeSource (Pointeur)   ` LongitudeSource (Pointeur)  ` LatitudeCible (Pointeur)   ` LongitudeCible (Pointeur)  ` ---------------------------------------------  ` MATHERROR  `   0 -> Pas d'erreur  ` -1 -> TypeConversion inexistant  ` ---------------------------------------------  `  (translation : BE 03-2010)End if C_LONGINT(MATHERROR)MATHERROR:=0C_TEXT($1)  ` type de conversionC_POINTER($2;$3;$4;$5)  ` ptr source lat et long ; cible lat et longC_REAL($Tx;$Ty;$Tz)C_REAL($Source_Lat;$Source_Long;$Cible_Lat;$Cible_Long)C_REAL($DatumOrigine_a;$DatumOrigine_e2;$DatumDestination_a;$DatumDestination_e2)If (False)C_TEXT(MTH_GDY_Datum ;$1)C_POINTER(MTH_GDY_Datum ;$2)C_POINTER(MTH_GDY_Datum ;$3)C_POINTER(MTH_GDY_Datum ;$4)C_POINTER(MTH_GDY_Datum ;$5)End if Case of : ($1="ED50_Vers_WGS84")$Tx:=-84$Ty:=-97$Tz:=-117$DatumOrigine_a:=MTH_GDY_Constants ("Hayford_a")$DatumOrigine_e2:=MTH_GDY_Constants ("Hayford_e2")$DatumDestination_a:=MTH_GDY_Constants ("Iagrs_a")$DatumDestination_e2:=MTH_GDY_Constants ("Iagrs_e2"): ($1="WGS84_Vers_ED50")$Tx:=84$Ty:=97$Tz:=117$DatumOrigine_a:=MTH_GDY_Constants ("Iagrs_a")$DatumOrigine_e2:=MTH_GDY_Constants ("Iagrs_e2")$DatumDestination_a:=MTH_GDY_Constants ("Hayford_a")$DatumDestination_e2:=MTH_GDY_Constants ("Hayford_e2"): ($1="ED50_Vers_NTF")$Tx:=84$Ty:=-37$Tz:=-437$DatumOrigine_a:=MTH_GDY_Constants ("Hayford_a")$DatumOrigine_e2:=MTH_GDY_Constants ("Hayford_e2")$DatumDestination_a:=MTH_GDY_Constants ("Clarke_a")$DatumDestination_e2:=MTH_GDY_Constants ("Clarke_e2"): ($1="NTF_Vers_ED50")$Tx:=-84$Ty:=37$Tz:=437$DatumOrigine_a:=MTH_GDY_Constants ("Clarke_a")$DatumOrigine_e2:=MTH_GDY_Constants ("Clarke_e2")$DatumDestination_a:=MTH_GDY_Constants ("Hayford_a")$DatumDestination_e2:=MTH_GDY_Constants ("Hayford_e2"): ($1="NTF_Vers_WGS84")$Tx:=-168$Ty:=-60$Tz:=320$DatumOrigine_a:=MTH_GDY_Constants ("Clarke_a")$DatumOrigine_e2:=MTH_GDY_Constants ("Clarke_e2")$DatumDestination_a:=MTH_GDY_Constants ("Iagrs_a")$DatumDestination_e2:=MTH_GDY_Constants ("Iagrs_e2"): ($1="WGS84_Vers_NTF")$Tx:=168$Ty:=60$Tz:=-320$DatumOrigine_a:=MTH_GDY_Constants ("Iagrs_a")$DatumOrigine_e2:=MTH_GDY_Constants ("Iagrs_e2")$DatumDestination_a:=MTH_GDY_Constants ("Clarke_a")$DatumDestination_e2:=MTH_GDY_Constants ("Clarke_e2")Else MATHERROR:=-1End case If (MATHERROR=0)  `lecture source et transformation en radians$Source_Lat:=($2->)*(Pi /180)$Source_Long:=($3->)*(Pi /180)  `Coordonnées géocentriques sur l'ellipsoïde de destination $V:=$DatumOrigine_a/(Square root(1-($DatumOrigine_e2*(Sin($Source_Lat)^2))))  `Variables calculées en mètres $X:=$V*Cos($Source_Lat)*Cos($Source_Long)+$Tx$Y:=$V*Cos($Source_Lat)*Sin($Source_Long)+$Ty$Z:=$V*(1-$DatumOrigine_e2)*Sin($Source_Lat)+$Tz$R:=Square root(($X^2)+($Y^2))  `Coordonnées géographiques sur l'ellipsoïde de destination $Cible_Long:=Arctan($Y/$X)  `en radians$ecart:=1$Phi:=$Source_Lat/Pi /Pi   `pourquoi ?$Iter:=0Repeat $Phi_1:=$DatumDestination_e2*Sin($Phi)*$DatumDestination_a/Square root(1-($DatumDestination_e2*(Sin($Phi)^2)))$Phi_1:=Arctan($Z+$Phi_1/$R)$ecart:=Abs($Phi-$Phi_1)$Phi:=$Phi_1$Iter:=$Iter+1Until (1000*$ecart<0,00001) | ($Iter=10)$Cible_Lat:=$Phi  `en radians  ` SORTIE$Cible_Long:=$Cible_Long/(Pi /180)  `en DD$Cible_Lat:=$Cible_Lat/(Pi /180)$4->:=$Cible_Lat$5->:=$Cible_LongEnd if 