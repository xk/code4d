  `This method is part from Math4D project 2002-2010 with authors : Jacques Bossy, Philip Burns, Olivier Deschanels, Marc Duc-Jacquet  `Bernard Escaich, Antoine Galmiche, Micaël Germann, George F. Huhn, Nicolas Jore, Teddy Linet, Frédéric Quoirez, Michel Saiz, Robert Van LooIf (False)  ` MATH_Evaluation [Antoine Galmiche 20/07/2004]   ` ------------------------------------------------------  ` ---------------   E N G L I S H   -----------------  ` ------------------------------------------------------  ` This function allows to evaluate a mathematic function for a fixed value.  ` It doesn't use the 4D command EXECUTE  ` It is essential that those rules are respected :  ` -- Only use the math functions of 4D language :  `         Abs, Int, Log, Sin, Cos, Tan, Arctan, Square root  ` -- Respect 4D syntax for math expressions  ` -- The unknown must be x or X (the character)  ` -- Only use 4D operators : + - * / \ ^ %  ` -- 4D constants can be used  ` It's possible to change the initial settings such as separators, line number format etc.  ` ---------------------------------------------  ` MATH_Evaluation (Expression ; Number) -> Real  ` Expression (Text) Text of the mathematical function  ` Number (Real) Number the function will be applyed to  ` result (Real) Result of the function  ` ---------------------------------------------  ` MATHERROR  `  0 -> No error  ` -1 -> Expression is not balanced  ` -2 -> Forbidden signs in the expression  ` ---------------------------------------------  ` EXEMPLE :  ` $tot:=MATH_Evaluation ("sin(x+1)-cos(1/(x^2))";Pi )  `   ` note : important sections of the method are translated  ` ------------------------------------------------------  ` ---------------   F R A N C A I S  ---------------  ` ------------------------------------------------------  ` Cette fonction permet d'évaluer une expression mathématique pour une valeur donnée.  ` Elle n'utilise pas la commande EXECUTER  ` Il est impératif que l'expression respecte les règles suivantes :  ` -- N'utiliser que les fonctions 4D :  `      Abs, Ent, Racine carrée, Log, Exp, Sin, Cos, Tan, Arctan  ` -- Respecter la syntaxe 4D pour les expressions mathématiques  ` -- L'inconnue est x ou X (la lettre)  ` -- Les opérateurs sont ceux de 4D :  `     + - * / \ ^ %  ` -- Il est possible d'utiliser les constantes 4D  ` Il est possible de changer les réglages de départ comme les éléments séparateurs, le format des numéros de ligne etc.  ` ---------------------------------------------  ` MATH_Evaluation (Expression ; Nombre) -> Numérique  ` Expression (Texte) Texte de la fonction mathématique  ` Nombre (Numérique) Nombre auquel la fonction sera appliquée  ` résultat (Numérique) Résultat de la résolution  ` ---------------------------------------------  ` MATHERROR  `  0 -> Pas d'erreur  ` -1 -> L'expression n'est pas équilibrée  ` -2 -> L'expression comporte des signes interdits  ` ---------------------------------------------  ` EXEMPLE :  ` $tot:=MATH_Evaluation ("sin(x+1)-cos(1/(x^2))";Pi )  ` ------------------------------------------------------  ` (translation : AG - 03/2007)End if C_LONGINT(MATHERROR)C_TEXT($1)  ` texte de la formuleC_REAL($2)  ` valeur x à calculerC_REAL($0;$m;$n)  ` résultat du calculIf (False)C_REAL(MTH_ANL_Evaluation ;$0)C_TEXT(MTH_ANL_Evaluation ;$1)C_REAL(MTH_ANL_Evaluation ;$2)End if C_TEXT($txt)  ` ligne à évaluer, sans sous-calculC_STRING(1;$car;$term;$sep;$sepdec)C_STRING(255;$format)C_STRING(255;$op;$m1;$m2)  ` (m1 op m2)C_STRING(255;$chiffres;$operateurs;$fonctions)C_LONGINT($i;$j;$k)$0:=0MATHERROR:=0  ` ----------------  REGLAGES (settings)$sep:="?"  ` caractere isolant la référence à une autre ligne ?000?  ` (char to isolate the reference to another line)$format:="000"  ` format utilisé pour signaler une autre ligne  ` (format to indicate another line)$term:=Char(9)  ` situé à la fin d'une ligne, il indique qu'elle doit/peut être évaluée  ` (at the end of a line it means that evaluation can/must be done)$sepdec:=Substring(String(1/2);2;1)  ` caractère séparateur de décimales  ` (separate char for decimals)$chiffres:="0123456789"+$sepdec$operateurs:="+-*/\\^%"$fonctions:="ABCDEFGHI"  ` ---------------- D'ABORD ON NETTOIE TOUT (first : clean)If ($1≤1≥="-")$txt:="0"+$1Else $txt:=$1End if $txt:=Replace string($txt;"degre";"0"+$sepdec+"0174532925199432958")$txt:=Replace string($txt;"nombre e";"2"+$sepdec+"71828182845904524")$txt:=Replace string($txt;"pi";"3"+$sepdec+"141592653589793239")$txt:=Replace string($txt;"radian";"57"+$sepdec+"29577951308232088")$txt:=Replace string($txt;"[";"(")$txt:=Replace string($txt;"{";"(")$txt:=Replace string($txt;"]";")")$txt:=Replace string($txt;"}";")")Repeat   ` enlevons les espaces$txt:=Replace string($txt;" ";"")Until (Position(" ";$txt)=0)  ` vérification formule correcte$txt2:=$txt$txt2:=Replace string($txt2;"abs";"")$txt2:=Replace string($txt2;"ent";"")$txt2:=Replace string($txt2;"racinecarree";"")$txt2:=Replace string($txt2;"log";"")$txt2:=Replace string($txt2;"exp";"")$txt2:=Replace string($txt2;"sin";"")$txt2:=Replace string($txt2;"cos";"")$txt2:=Replace string($txt2;"arctan";"")$txt2:=Replace string($txt2;"tan";"")$txt2:=Replace string($txt2;"1";"")$txt2:=Replace string($txt2;"2";"")$txt2:=Replace string($txt2;"3";"")$txt2:=Replace string($txt2;"4";"")$txt2:=Replace string($txt2;"5";"")$txt2:=Replace string($txt2;"6";"")$txt2:=Replace string($txt2;"7";"")$txt2:=Replace string($txt2;"8";"")$txt2:=Replace string($txt2;"9";"")$txt2:=Replace string($txt2;"0";"")$txt2:=Replace string($txt2;$sepdec;"")$txt2:=Replace string($txt2;"(";"")$txt2:=Replace string($txt2;")";"")$txt2:=Replace string($txt2;"+";"")$txt2:=Replace string($txt2;"-";"")$txt2:=Replace string($txt2;"*";"")$txt2:=Replace string($txt2;"/";"")$txt2:=Replace string($txt2;"\\";"")$txt2:=Replace string($txt2;"%";"")$txt2:=Replace string($txt2;"^";"")$txt2:=Replace string($txt2;"x";"")If ($txt2#"")  ` signes incongrusMATHERROR:=-2Else   ` ensuite, traitons les fonctions math de 4D (translate 4D math functions)$txt:=Replace string($txt;"abs";"A")$txt:=Replace string($txt;"ent";"B")$txt:=Replace string($txt;"racinecarree";"C")$txt:=Replace string($txt;"log";"D")$txt:=Replace string($txt;"exp";"E")$txt:=Replace string($txt;"sin";"F")$txt:=Replace string($txt;"cos";"G")$txt:=Replace string($txt;"arctan";"H")$txt:=Replace string($txt;"tan";"I")  ` ----------------  C'EST PARTI MON KIKI (let's go my whowho !)ARRAY TEXT($tab;1)$j:=1  ` ligne courante$k:=1  ` dernier numéro de ligne utilisé$tab{1}:=""For ($i;1;Length($txt))  ` d'abord répartir les expressions incluses dans un tableau$car:=$txt≤$i≥  ` 1 ligne correspond à une expressionCase of : (Position($car;$fonctions)#0)  ` ouverture d'une fonction$k:=$k+1  ` on va utiliser la ligne suivante$tab{$j}:=$tab{$j}+String($k;$sep+$format+$sep)  ` on inscrit dans la ligne courante le n° de ligne du résultatINSERT IN ARRAY($tab;Size of array($tab)+1)$tab{Size of array($tab)}:=String($j;$format)+$car$j:=$k  ` on change de ligne courante pour l'écriture de la suite      : ($car="(")  `( -> on ajoute une ligne$k:=$k+1  ` on va utiliser la ligne suivante$tab{$j}:=$tab{$j}+String($k;$sep+$format+$sep)  ` on inscrit dans la ligne courante le n° de ligne du résultatINSERT IN ARRAY($tab;Size of array($tab)+1)$tab{Size of array($tab)}:=String($j;$format)$j:=$k  ` on change de ligne courante pour l'écriture de la suite: ($car=")")  ` parenthèse fermante -> on remonte à l'origineIf (Position($sep;$tab{$j})=0)$tab{$j}:=$tab{$j}+$term  ` ligne à calculer directement -> terminaisonEnd if Repeat   ` il faut remonter jusqu'à une ligne sans fonction$j:=Num(Substring($tab{$j};1;Length($format)))Until (($j=1) | (Position($tab{$j}≤(1+Length($format))≥;$fonctions)=0))  ` numéro de la ligne d'origine Else   ` rien de spécial, on continue à remplir la ligne courante$tab{$j}:=$tab{$j}+$carEnd case End for If ((Position($sep;$tab{1})=0) & (Position($sep;$tab{1})=0))$tab{1}:=$tab{1}+$termEnd if If ($j#1)  ` erreur dans la formuleMATHERROR:=-1Else   ` ---------------------  ` traitement du tableau (array treatment)  ` ---------------------Repeat For ($i;Size of array($tab);1;-1)If (Substring($tab{$i};Length($tab{$i}))=$term)  ` ligne qu'il faut évaluer$tab{$i}:=Substring($tab{$i};1;Length($tab{$i})-1)  ` enlever le dernier car ($term)      If ($i#1)$k:=Num(Substring($tab{$i};1;Length($format)))  ` n° ligne appelante           $tab{$i}:=Substring($tab{$i};Length($format)+1)  ` enlever la référence à la ligne appelante           End if   ` ---------------------  ` calcul de la ligne (calculating the line)  ` ---------------------         $txt:=$tab{$i}$txt:=Replace string($txt;")";"")  ` enlever les parenthèses fermantes il ne doit plus y en avoir ?$txt:=Replace string($txt;"x";String($2))  ` on insert l'inconnueIf (Position($tab{$i}≤1≥;$fonctions)#0)  ` une fonction : F-0,3456$txt:=$tab{$i}≤1≥  ` la fonction$mot:=Substring($tab{$i};2)  ` le nombre a évaluerCase of   ` immédiatement: ($txt="A")$0:=Abs(Num($mot)): ($txt="B")$0:=Int(Num($mot)): ($txt="C")$0:=Square root(Num($mot)): ($txt="D")$0:=Log(Num($mot)): ($txt="E")$0:=Exp(Num($mot)): ($txt="F")$0:=Sin(Num($mot)): ($txt="G")$0:=Cos(Num($mot)): ($txt="H")$0:=Arctan(Num($mot)): ($txt="I")$0:=Tan(Num($mot))End case Else   ` une expression linéaire  If ($txt="-@")  ` ne pas oublier le cas (- expressoin)$txt:="0"+$txtEnd if $op:=""  ` maintenant il faut résoudre les opérations de base$m1:=""$m2:=""$bOK:=FalseFor ($j;1;Length($txt))$car:=$txt≤$j≥Case of : ($j=Length($txt))  ` il faut évaluer   If ($op="")  ` un seul membre$0:=Num($m1+$car)  ` expression seule    Else $m2:=$m2+$car  ` terminer le second membre avant l'opération   Case of : ($op="+")$0:=Num($m1)+Num($m2): ($op="-")$0:=Num($m1)-Num($m2): ($op="*")$0:=Num($m1)*Num($m2): ($op="/")$0:=Num($m1)/Num($m2): ($op="\\")$0:=Num($m1)\Num($m2): ($op="^")$0:=Num($m1)^Num($m2): ($op="%")$0:=Num($m1)%Num($m2)End case End if : (Position($car;$operateurs)#0)  ` on rencontre un opérateurIf ($m2="")  ` il n'y a pas encore de second membreIf ($op="")  ` pas encore d'opérateur$op:=$car  ` c'est l'opérateur           Else   ` un opérateur existe mais pas de m2$m2:=$car  ` m2 doit être négatif                  End if Else   ` il y a un m2, donc un opérateurCase of : ($op="+")$0:=Num($m1)+Num($m2): ($op="-")$0:=Num($m1)-Num($m2): ($op="*")$0:=Num($m1)*Num($m2): ($op="/")$0:=Num($m1)/Num($m2): ($op="\\")$0:=Num($m1)\Num($m2): ($op="^")$0:=Num($m1)^Num($m2): ($op="%")$0:=Num($m1)%Num($m2)End case $m1:=String($0)$m2:=""$op:=$carEnd if Else   ` caractère normal, on continue à remplir les membres m1 ou m2If ($op="")  ` opérateur encore indéfini -> $m1$m1:=$m1+$carElse $m2:=$m2+$carEnd if End case End for End if   ` ---------------------  ` fin du calcul de la ligne (end of line calculation)  ` ---------------------    If ($i#1)  ` si ce n'est pas la dernière évaluation (ligne 1)   $tab{$k}:=Replace string($tab{$k};$sep+String($i;$format)+$sep;String($0))  ` insérer le résultat dans la ligne appelanteIf (Position($sep;$tab{$k})=0)  ` il n'y a plus de références incluses$tab{$k}:=$tab{$k}+$term  ` la ligne appelante peut être calculéeEnd if DELETE FROM ARRAY($tab;$i)  ` supprimer la ligne évaluéeEnd if End if End for Until (Size of array($tab)=1)End if End if 