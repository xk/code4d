  `This method is part from Math4D project 2002-2010 with authors : Jacques Bossy, Philip Burns, Olivier Deschanels, Marc Duc-Jacquet  `Bernard Escaich, Antoine Galmiche, Micaël Germann, George F. Huhn, Nicolas Jore, Teddy Linet, Frédéric Quoirez, Michel Saiz, Robert Van LooIf (False)  ` MATH_NTF_LambertVersSexa [Marc Duc-Jacquet, Antoine Galmiche 05/2007]  ` d'après Serge Milles  ` ------------------------------------------------------  ` ---------------   E N G L I S H   -----------------  ` ------------------------------------------------------  ` Data conversion    `  $1,$2,$3,$4 pointers on reals     ` $1,$2  for  latitude and longitude of source  ` $3,$4 for  latitude and longitude of target .   ` Those values are in DD and signed  `  latitude (>0 if N, <0 if S) and longitude ( >0 if E, <0 if W)  ` $3 et $4 latitude and longitude of target are also signed  ` ---------------------------------------------  ` MATH_NTF_LambertVersSexa (->LAMB_X;->LAMB_Y;->NTF_Lat;->NTF_Long)  ` ---------------------------------------------  ` MATHERROR  ` 0 -> No error  ` ------------------------------------------------------  ` ---------------   F R A N C A I S  ---------------    ` ------------------------------------------------------   ` Conversion données  `  $1,$2,$3,$4 pointeurs sur des réels   $1,$2  pour  lat long  de la source  ` $3,$4 pour lat long de la cible . Ces quantités sont en DD et signées:  `  latitude (>0 si N, <0 si S) et longitude ( >0 si E, <0 si W)  ` $3 et $4 lat et long cible sont également signées  ` ---------------------------------------------  ` MATH_NTF_LambertVersSexa (->LAMB_X;->LAMB_Y;->NTF_Lat;->NTF_Long)  ` ---------------------------------------------  ` MATHERROR  ` 0 -> Pas d'erreur  ` ---------------------------------------------  `  (translation : BE 03-2010)End if C_LONGINT(MATHERROR)MATHERROR:=0C_POINTER($1;$2;$3;$4)C_REAL($Lamb_EE;$Lamb_NN;$Lamb_Zone;$Lamb_a;$Lamb_f;$Lamb_b;$Lamb_e)C_REAL($Lamb_Phi0;$Lamb_Phi1;$Lamb_Phi2;$Lamb_vo1;$Lamb_vo2;$Lamb_po1;$Lamb_po2)C_REAL($Lamb_m;$Lamb_m1;$Lamb_m2;$Lamb_CE;$Lamb_CN;$Lamb_mL;$Lamb_v0;$Lamb_R0)C_REAL($Lamb_mLR0;$Lamb_Ls;$Lamb_E1;$Lamb_N1;$Lamb_gamma;$Lamb_Lambda0)C_REAL($NTF_Lambda;$Lamb_R;$Lamb_L0;$Lamb_L;$ecart;$Phi;$Phi_1;$NTF_Phi)C_REAL($un;$deux;$trois)If (False)C_POINTER(MTH_GDY_NTF_LambertToSexa ;$1)C_POINTER(MTH_GDY_NTF_LambertToSexa ;$2)C_POINTER(MTH_GDY_NTF_LambertToSexa ;$3)C_POINTER(MTH_GDY_NTF_LambertToSexa ;$4)End if   `lecture source  en DD$Lamb_EE:=($1->)$Lamb_NN:=($2->)  `Début des calculs $Lamb_Zone:=Int($Lamb_NN/1000000)$Lamb_a:=MTH_GDY_Constants ("Clarke_a")$Lamb_f:=293,4660213$Lamb_b:=$Lamb_a*(1-(1/$Lamb_f))$Lamb_e:=Square root((($Lamb_a^2)-($Lamb_b^2))/($Lamb_a^2))$Lamb_Phi1:=50,99879884/200*180$Lamb_Phi2:=52,99557167/200*180$Lamb_vo1:=$Lamb_a/Square root(1-(($Lamb_e^2)*((Sin($Lamb_Phi1*Pi /180)^2))))$Lamb_vo2:=$Lamb_a/Square root(1-(($Lamb_e^2)*((Sin($Lamb_Phi2*Pi /180)^2))))$Lamb_Phi0:=52*0,9$un:=($Lamb_e^2)*((Sin($Lamb_Phi1*Pi /180))^2)$un:=Square root(1-$un)$un:=($un^3)$Lamb_po1:=$Lamb_a*(1-($Lamb_e^2))/$un$un:=($Lamb_e^2)*((Sin($Lamb_Phi2*Pi /180))^2)$un:=Square root(1-$un)$un:=($un^3)$Lamb_po2:=$Lamb_a*(1-($Lamb_e^2))/$un$Lamb_m1:=1+($Lamb_po1/2/$Lamb_vo1*(($Lamb_Phi1-$Lamb_Phi0)*Pi /180^2))$Lamb_m2:=1+($Lamb_po2/2/$Lamb_vo2*(($Lamb_Phi2-$Lamb_Phi0)*Pi /180^2))$Lamb_m:=($Lamb_m1+$Lamb_m2)/2$Lamb_CE:=600$Lamb_CN:=2200$Lamb_mL:=2-$Lamb_m$un:=($Lamb_e^2)*(Sin($Lamb_Phi0*Pi /180)^2)$Lamb_v0:=$Lamb_a/Square root(1-$un)$Lamb_R0:=$Lamb_v0/Tan($Lamb_Phi0*Pi /180)$Lamb_mLR0:=$Lamb_mL*$Lamb_R0$un:=Log(Tan((Pi /4)+($Lamb_Phi0/2*Pi /180)))$deux:=1+($Lamb_e*Sin($Lamb_Phi0*Pi /180))$trois:=1-($Lamb_e*Sin($Lamb_Phi0*Pi /180))$Lamb_Ls:=$un-($Lamb_e/2*Log($deux/$trois))  `Math.log(Math.tan(Math.PI / 4 + Lamb_Phi0 / 2 * Math.PI / 180)) - Lamb_e / 2 * Math.log((1 + Lamb_e * Math.sin(Lamb_Phi0 * Math.PI / 180 )) / (1 - Lamb_e * Math.sin(Lamb_Phi0 * Math.PI / 180)))$Lamb_E1:=$Lamb_EE-($Lamb_CE*1000)$Lamb_N1:=$Lamb_NN-($Lamb_CN*1000)$Lamb_gamma:=Arctan($Lamb_E1/($Lamb_mLR0-$Lamb_N1))*180/Pi $Lamb_Lambda0:=2,596921296/200*180  `longitude (signée) cherchée en DD$NTF_Lambda:=($Lamb_gamma/Sin($Lamb_Phi0*Pi /180)+$Lamb_Lambda0)$Lamb_R:=($Lamb_mLR0-$Lamb_N1)/Cos($Lamb_gamma*Pi /180)$un:=Log(Tan((Pi /4)+($Lamb_Phi0/2*Pi /180)))$deux:=1+($Lamb_e*Sin($Lamb_Phi0*Pi /180))$trois:=1-($Lamb_e*Sin($Lamb_Phi0*Pi /180))$Lamb_L0:=$un-($Lamb_e/2*Log($deux/$trois))$Lamb_L:=$Lamb_L0+(Log($Lamb_mLR0/$Lamb_R)/Sin($Lamb_Phi0*Pi /180))$ecart:=1$Phi:=2*Arctan(Exp($Lamb_L))-(Pi /2)Repeat   `$un:=($Lamb_e*Sin($Phi)+1)/(-$Lamb_e*Sin($Phi)+1)  `$un:=$Lamb_e/2*Log($un)  `$Phi_1:=2*Arctan(Exp($Lamb_L+$un)))-(Pi /2)$Phi_1:=2*(Arctan(Exp($Lamb_L+($Lamb_e/2*Log((1+($Lamb_e*Sin($Phi)))/(1-($Lamb_e*Sin($Phi))))))))-(Pi /2)$ecart:=Abs($Phi_1-$Phi)$Phi:=$Phi_1Until (1000*$ecart<0,00001)  `Latitude (signée) cherchée en DD$NTF_Phi:=$Phi*180/Pi   `SORTIES  en DD$3->:=$NTF_Phi  ` latitude$4->:=$NTF_Lambda  `  longitude