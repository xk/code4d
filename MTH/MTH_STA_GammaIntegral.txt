  `This method is part from Math4D project 2002-2010 with authors : Jacques Bossy, Philip Burns, Olivier Deschanels, Marc Duc-Jacquet  `Bernard Escaich, Antoine Galmiche, Micaël Germann, George F. Huhn, Nicolas Jore, Teddy Linet, Frédéric Quoirez, Michel Saiz, Robert Van Loo  If (False)  ` MTH_STA_GammaIntegral (was MATH_IntegralGammaIncomp) [Teddy LINET 02/2003 et Philip BURNS 1985]  ` ------------------------------------------------------  ` ---------------   E N G L I S H   -----------------  ` ------------------------------------------------------  ` WARNING : This method needs MATH_LogGamma  ` ---------------------------------------------  ` Math's summary  ` Evaluates integral of function Gamma "Uncomplete"  ` from 0 to value $y_F  `   ` Gamma function is integral on t between 0 and + infinite of function  ` f(x)=(1/gamma(alpha))*(lambda^alpha)*(x^(alpha-1))*exp(-lambda*x)  ` ou gamma(t) is integral between 0 and + infinite from f(t)=t^z-1*exp(-t)  ` It has, among other things, the characteristic  : gamma(z+1)=z*gamma(z)  `    ` It is useful in statistics, why for instance, we can demonstrate than the distribution of a khi 2 function  ` follows a gamma function (X2/2;ddl/2)  `  ` Notice : this method uses in accordance to arguments' value  ` else a infinite sum of a serie, else a continuous fraction  ` ---------------------------------------------  ` Syntax :  ` MATH_IntegralGammaIncomp($y_F; $ddl_F;$vDprec_I ;$vMaxIter_I)  ` $y_F :             Gamma distribution value  ` $ddl_F :         Degrees of freedom    ` $vDprec_I :   Precision degree  ` $vMaxIter_I :  Maximum number of iterations  ` ---------------------------------------------    ` MATHERROR  `  0 -> No error  ` -1 -> $y_F <=0  ` -2 -> $ddl_F <=0  ` -3 -> Value of intermediate parameter $vF_F is smaller than minimum  ` -4 -> Value of intermediate parameter exp ($vF_F) is zero  ` ------------------------------------------------------  ` ---------------   F R A N C A I S  ---------------  ` ------------------------------------------------------  ` ATTENTION : nécessite MATH_LogGamma  ` ---------------------------------------------  ` Rappels mathématiques :  ` Evalue l'intégrale de la fonction Gamma "Incomplète"  ` soit de 0 à la valeur $y_F  `   ` La fonction gamma est l'intégrale sur t entre 0 et + l'infini de la fonction  ` f(x)=(1/gamma(alpha))*(lambda^alpha)*(x^(alpha-1))*exp(-lambda*x)  ` ou gamma(t) est l'intégrale entre 0 et + l'infini de f(t)=t^z-1*exp(-t)  ` Elle a entre autre la particularité que gamma(z+1)=z*gamma(z)  `    ` Elle est utile en statistiques car par exemple on peut démontrer que la  ` distribution d'une fonction khi 2 suit une fonction gamma(X2/2;ddl/2)  `  ` Remarque : Utilise en fonction des valeurs des arguments  ` soit une somme infinie de série soit une fraction continue  ` ---------------------------------------------  ` Ecriture :  ` MATH_IntegralGammaIncomp($y_F; $ddl_F;$vDprec_I ;$vMaxIter_I)  ` $y_F : Valeur de la distribution gamma  ` $ddl_F : degrés de liberté   ` $vDprec_I : degré de précision  ` $vMaxIter_I : Nombre max d'iteration  ` ---------------------------------------------    ` MATHERROR  `  0 -> Pas d'erreur  ` -1 -> $y_F <=0  ` -2 -> $ddl_F <=0  ` -3 -> La valeur du paramètre intermédiaire $vF_F est inférieure au minimum  ` -4 -> La valeur du paramètre intermédiaire exp($vF_F) est nulle  ` ------------------------------------------------------  `  (translation : BE 3-2010)End if C_REAL($0;$1;$y_F;$2;$ddl_F;$vIntegrale_F)C_INTEGER($3;$vDprec_I;$4;$vMaxIter_I)If (False)C_REAL(MTH_STA_GammaIntegral ;$0)C_REAL(MTH_STA_GammaIntegral ;$1)C_REAL(MTH_STA_GammaIntegral ;$2)C_LONGINT(MTH_STA_GammaIntegral ;$3)C_LONGINT(MTH_STA_GammaIntegral ;$4)End if C_REAL($vCprec_F)C_INTEGER($vIter_I)C_LONGINT(MATHERROR)$y_F:=$1$ddl_F:=$2  ` S'adapter en fonction du nombre de parametresIf (Count parameters>2)$vDprec_I:=Abs($3)Else $vDprec_I:=12End if If (Count parameters>3)$vMaxIter_I:=Abs($4)Else $vMaxIter_I:=200End if   `VARIABLESC_REAL($vF_F;$vC_F;$vA_F)C_REAL($B_F;$vTerm_F)ARRAY REAL($tPn_F;6)C_REAL($vGin_F;$vAn_F;$vRn_F)C_REAL($vDif_F;$vEps_F)C_BOOLEAN($vDone_B)  `CONSTANTESC_REAL($vOflo_F;$vMinExp_F;$vMaxPrec_F)$vMaxPrec_F:=16  ` Précision$vOflo_F:=10^37$vMinExp_F:=-87$vIntegrale_F:=1If (($y_F>0) & ($ddl_F>0))  `   Analyse la valeur de $vF_F$vF_F:=Log($y_F)$vF_F:=$ddl_F*$vF_F$vF_F:=$vF_F-MTH_STA_GammaLog ($ddl_F+1)$vF_F:=$vF_F-$y_F  ` soit $vF_F:=($ddl_F*Log($y_F))-MATH_LogGamma ($ddl_F+1)-$y_FIf ($vF_F>=$vMinExp_F)$vF_F:=Exp($vF_F)If ($vF_F#0)  ` Mise en place de la précisionCase of : ($vDprec_I>$vMaxPrec_F)$vDprec_I:=$vMaxPrec_F: ($vDprec_I<=0)$vDprec_I:=1End case $vCprec_F:=$vDprec_I$vEps_F:=10^-$vDprec_I  `  Choisi entre les séries infinies ou les fractions continuesIf (($y_F>1) & ($y_F>=$ddl_F))  ` Fractions continues        $vA_F:=1-$ddl_F$B_F:=$vA_F+$y_F+1$vTerm_F:=0$tPn_F{1}:=1$tPn_F{2}:=$y_F$tPn_F{3}:=$y_F+1$tPn_F{4}:=$y_F*$B_F$vGin_F:=$tPn_F{3}/$tPn_F{4}$vDone_B:=False$vIter_I:=0Repeat $vIter_I:=$vIter_I+1$vA_F:=$vA_F+1$B_F:=$B_F+2$vTerm_F:=$vTerm_F+1$vAn_F:=$vA_F*$vTerm_F$tPn_F{5}:=$B_F*$tPn_F{3}$tPn_F{5}:=$tPn_F{5}-($vAn_F*$tPn_F{1})  ` soit $tPn_F{5}:=($B_F*$tPn_F{3})-($vAn_F*$tPn_F{1})$tPn_F{6}:=$B_F*$tPn_F{4}$tPn_F{6}:=$tPn_F{6}-($vAn_F*$tPn_F{2})  ` Soit $tPn_F{6}:=($B_F*$tPn_F{4})-($vAn_F*$tPn_F{2})If ($tPn_F{6}#0)$vRn_F:=$tPn_F{5}/$tPn_F{6}$vDif_F:=Abs($vGin_F-$vRn_F)If ($vDif_F<=$vEps_F) & ($vDif_F<=($vEps_F*$vRn_F))$vDone_B:=TrueEnd if $vGin_F:=$vRn_FEnd if $tPn_F{1}:=$tPn_F{3}$tPn_F{2}:=$tPn_F{4}$tPn_F{3}:=$tPn_F{5}$tPn_F{4}:=$tPn_F{6}If (Abs($tPn_F{5})>=$vOflo_F)$tPn_F{1}:=$tPn_F{1}/$vOflo_F$tPn_F{2}:=$tPn_F{2}/$vOflo_F$tPn_F{3}:=$tPn_F{3}/$vOflo_F$tPn_F{4}:=$tPn_F{4}/$vOflo_FEnd if Until (($vIter_I>$vMaxIter_I) | $vDone_B)$vGin_F:=1-($vF_F*$vGin_F*$ddl_F)$vIntegrale_F:=$vGin_F  `  Calcule la précision du résultat (débogage, non renvoyé)  `If ($vDif_F#0)$vCprec_F:=-(Log($vDif_F)/Log(10))  ` Ou MATH_LogN($vDif_F;10)Else $vCprec_F:=$vMaxPrec_FEnd if Else   ` Séries infinies$vIter_I:=0$vTerm_F:=1$vC_F:=1$vA_F:=$ddl_F$vDone_B:=FalseRepeat $vA_F:=$vA_F+1$vTerm_F:=($vTerm_F*$y_F)/$vA_F$vC_F:=$vC_F+$vTerm_F$vIter_I:=$vIter_I+1Until (($vIter_I>$vMaxIter_I) | (($vTerm_F/$vC_F)<=$vEps_F))$vIntegrale_F:=$vC_F*$vF_F  `  Calcule la précision du résultat (débogage, non renvoyé)$vCprec_F:=-(Log($vTerm_F/$vC_F)/Log(10))  ` Ou MATH_LogN($vTerm_F/$vC_F;10)End if MATHERROR:=0  ` Tout s'est bien passéElse MATHERROR:=-4  ` La valeur du paramètre intermédiaire exp($vF_F) est nulleEnd if Else MATHERROR:=-3  ` La valeur du paramètre intermédiaire $vF_F est inférieure au minimumEnd if Else If ($y_F<=0)MATHERROR:=-1  ` Valeur de la distribution négatif ou nulElse MATHERROR:=-2  ` Degrés de liberté négatifs ou nulsEnd if End if $0:=$vIntegrale_F