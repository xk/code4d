C_REAL($1;$2;$3)C_INTEGER($4;$5)C_REAL($0)$0:=MTH_STA_CumulativeBetaDistrib ($1;$2;$3;$4;$5)If (False)  ` MATH_LoiBetaCumul [ Teddy LINET 02/03 et Philip BURNS 1985]  ` ------------------------------------------------------  ` ---------------   F R A N C A I S  ---------------  ` ------------------------------------------------------  `ATTENTION : nécessite MATH_LogGamma  `-------------------------------------------------  ` RAPPELS MATHEMATIQUES :  ` Evalue la distribution cumultative de la fonction Beta  "incomplète" (de 0 à x)  ` Utilise le développement de fraction continu tel qu'il a été décrit par Abramowitz et Stegun (1964)  `-------------------------------------------------  ` MATH_LoiBetaCumul ($vX_F;$vAlpha_F;$vBeta_F;$vDprec_I;$vMaxIter_I)-->R  ` $vX_F (Reel) point de pourcentage supérieur  ` $vAlpha_F (Reel)  Permier parametre de la fonction Beta  ` $vBeta_F (Reel)  Deuxième parametre de la fonction Beta  ` $vDprec_I (Entier) : degré de précision  ` $vMaxIter_I (Entier) : Nombre max d'iterations  ` ---------------------------------------------  ` MATHERROR  `  0 : Pas d'erreur  ` -1 : $vX_F<=0  ` -2 : $vAlpha_F<=0  ` -3 : $vBeta_F <=0   ` -4 : $vX_F>1  ` -5 : Calculs intermédiaires incompatibles  ` ------------------------------------------------------  ` ---------------   E N G L I S H   -----------------  ` ------------------------------------------------------  `ATTENTION : needs MATH_LogGamma  `-------------------------------------------------  `Math's summary  ` This method estimate cumultative distribution of incomplete beta function (from 0 to x)  `   ` It uses continued fractions development as described by Abramowitz et Stegun (1964)  `-------------------------------------------------  ` MATH_LoiBetaCumul ($vX_F;$vAlpha_F;$vBeta_F;$vDprec_I;$vMaxIter_I)-->R  ` $vX_F (Reel)              upper percentage point  ` $vAlpha_F (Reel)      First parameter of function Beta  ` $vBeta_F (Reel)        Second parameter of function Beta  ` $vDprec_I (Entier) :   Precision  ` $vMaxIter_I (Entier) :  Maximum number of iterations  ` ---------------------------------------------  ` MATHERROR  `   0 : No error  ` -1 : $vX_F<=0  ` -2 : $vAlpha_F<=0  ` -3 : $vBeta_F <=0   ` -4 : $vX_F>1  ` -5 : Intermediate calculations incompatibles  ` ------------------------------------------------------  `  (translation : BE 3-2010)  `End if C_REAL($vX_F;$1;$vAlpha_F;$2;$vBeta_F;$3)C_INTEGER($vDprec_I;$4;$vMaxIter_I;$5)C_REAL($vResultat_F;$0)$vX_F:=$1$vAlpha_F:=$2$vBeta_F:=$3$vDprec_I:=$4$vMaxIter_I:=$5C_REAL($vEpsz_F;$vA_F;$vB_F;$vProv_F)C_REAL($vC_F;$vF_F;$vFx_F)C_REAL($vApb_F;$vZm_F;$vAlo_F)C_REAL($vAhi_F;$vBlo_F;$vBhi_F)C_REAL($vBod_F;$vBev_F;$vZm1_F)C_REAL($vD1_F;$vAev_F;$vAod_F)C_BOOLEAN($vQswap_B;$vQconv_B;$vValide_F)C_REAL($vCprec_F)  ` Précision effective (non renvoyé : debog)C_INTEGER($vIter_I)  ` Itérations effectives (non renvoyé : debog)C_LONGINT(MATHERROR)  ` ConstantesC_INTEGER($vMaxPrec_I)C_REAL($vRsmall_F)$vMaxPrec_I:=16  ` Précision maximale   $vRsmall_F:=10^-300  ` Plus petit nombre à virgule flottante  `    Initialisation des variablesCase of : ($vDprec_I>$vMaxPrec_I)$vDprec_I:=$vMaxPrec_I: ($vDprec_I<=0)$vDprec_I:=1End case $vCprec_F:=$vDprec_I$vEpsz_F:=10^-$vDprec_I$vA_F:=$vAlpha_F$vB_F:=$vBeta_F$vQswap_B:=False$vResultat_F:=-1$vValide_F:=True  `  Evalue les arguments : MATHERROR si $vX_F <= 0 ; $vA_F <= 0 ; $vB_F <= 0 MATHERROR:=1If ($vX_F>0)If ($vA_F>0)If ($vB_F>0)  ` Si X >= 1 => Résultat = 1       $vResultat_F:=1If ($vX_F<1)  `  Si $vX_F > $vA_F / ( $vA_F + $vB_F ) => switch$vProv_F:=$vA_F+$vB_F$vProv_F:=$vA_F/$vProv_F  ` Soit $vProv_F:=($vA_F/($vA_F+$vB_F))If ($vX_F>$vProv_F)$vX_F:=1-$vX_F$vA_F:=$vBeta_F$vB_F:=$vAlpha_F$vQswap_B:=TrueEnd if   `  Recherche des valeurs extremes                   If (($vX_F#$vA_F) & ($vX_F#$vB_F))$vProv_F:=1-$vX_F$vProv_F:=($vB_F*$vX_F)/$vProv_F  ` Soit $vProv_F:=(($vB_F*$vX_F)/(1-$vX_F))If ($vA_F#$vProv_F)$vProv_F:=($vA_F+$vB_F)$vProv_F:=$vX_F*$vProv_F$vProv_F:=$vA_F-$vProv_F$vProv_F:=Abs($vProv_F)  ` Soit $vProv_F:=Abs($vA_F-($vX_F*($vA_F+$vB_F)))If ($vProv_F>$vEpsz_F)$vC_F:=MATH_LogGamma ($vA_F+$vB_F)$vC_F:=$vC_F+($vA_F*Log($vX_F))$vC_F:=$vC_F+($vB_F*Log(1-$vX_F))$vC_F:=$vC_F-MATH_LogGamma ($vA_F)-MATH_LogGamma ($vB_F)$vC_F:=$vC_F-Log($vA_F-($vX_F*($vA_F+$vB_F)))  ` soit $vC_F:=MATH_LogGamma ($vA_F+$vB_F)+($vA_F*Log($vX_F))  `+($vB_F*Log(1-$vX_F))-MATH_LogGamma ($vA_F)-MATH_LogGamma ($vB_F)  `-Log($vA_F-($vX_F*($vA_F+$vB_F)))If (($vC_F<-36) & $vQswap_B)$vValide_F:=FalseEnd if If ($vC_F<-180)$vResultat_F:=0$vValide_F:=FalseEnd if End if End if End if If ($vValide_F)$vApb_F:=$vA_F+$vB_F$vZm_F:=0$vAlo_F:=0$vBod_F:=1$vBev_F:=1$vBhi_F:=1$vBlo_F:=1$vAhi_F:=MATH_LogGamma ($vApb_F)$vAhi_F:=$vAhi_F+($vA_F*Log($vX_F))$vAhi_F:=$vAhi_F+($vB_F*Log(1-$vX_F))$vAhi_F:=$vAhi_F-MATH_LogGamma ($vA_F+1)-MATH_LogGamma ($vB_F)$vAhi_F:=Exp($vAhi_F)  ` soit $vAhi_F:=Exp(MATH_LogGamma ($vApb_F)+($vA_F*Log($vX_F))  ` +($vB_F*Log(1-$vX_F))-MATH_LogGamma ($vA_F+1)-MATH_LogGamma ($vB_F))$vF_F:=$vAhi_F$vIter_I:=0  `  `   Boucle des fractions continues. L'évaluation se poursuit jusqu'au maximum  `   d'itération ou à la convergence   $vQconv_B:=FalseRepeat $vFx_F:=$vF_F$vZm1_F:=$vZm_F$vZm_F:=$vZm_F+1$vD1_F:=$vA_F+$vZm_F+$vZm1_F$vAev_F:=-($vA_F+$vZm1_F)$vAev_F:=$vAev_F*($vApb_F+$vZm1_F)$vAev_F:=$vAev_F*$vX_F$vAev_F:=$vAev_F/$vD1_F$vAev_F:=$vAev_F/($vD1_F-1)  ` Soit $vAev_F:=-($vA_F+$vZm1_F)*($vApb_F+$vZm1_F)*$vX_F/$vD1_F/($vD1_F-1)$vAod_F:=$vZm_F*($vB_F-$vZm_F)$vAod_F:=$vAod_F*$vX_F$vAod_F:=$vAod_F/$vD1_F$vAod_F:=$vAod_F/($vD1_F+1)  ` Soit $vAod_F:=$vZm_F*($vB_F-$vZm_F)*$vX_F/$vD1_F/($vD1_F+1)$vAlo_F:=($vBev_F*$vAhi_F)+($vAev_F*$vAlo_F)$vBlo_F:=($vBev_F*$vBhi_F)+($vAev_F*$vBlo_F)$vAhi_F:=($vBod_F*$vAlo_F)+($vAod_F*$vAhi_F)$vBhi_F:=($vBod_F*$vBlo_F)+($vAod_F*$vBhi_F)If (Abs($vBhi_F)<$vRsmall_F)$vBhi_F:=0End if If ($vBhi_F#0)$vF_F:=$vAhi_F/$vBhi_F$vQconv_B:=(Abs(($vF_F-$vFx_F)/$vF_F)<$vEpsz_F)End if   `            $vIter_I:=$vIter_I+1Until (($vIter_I>$vMaxIter_I) | $vQconv_B)  `      Convergence, achèvement ou itérations max dépassées  If ($vQswap_B)$vResultat_F:=1-$vF_FElse $vResultat_F:=$vF_FEnd if   ` Calcule la précition du résultat (non renvoyé, pour débogage)If (Abs($vF_F-$vFx_F)#0)$vCprec_F:=-(Log(Abs($vF_F-$vFx_F))/Log(10))  ` ou MATH_LogN(Abs($vF_F-$vFx_F))Else $vCprec_F:=$vMaxPrec_IEnd if MATHERROR:=0  ` Tout s'est bien passéElse MATHERROR:=-5  ` Calculs intermédiaires incompatiblesEnd if Else MATHERROR:=-4  ` $vX_F>1End if Else MATHERROR:=-3  ` $vBeta_F <=0      End if Else MATHERROR:=-2  ` $vAlpha_F<=0End if Else MATHERROR:=-1  ` $vX_F<=0End if   `$0:=$vResultat_FEnd if 