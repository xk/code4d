C_REAL($1;$2;$3;$4)C_POINTER($5;$6;$7)$0:=MTH_GDY_GreatCircle ($1;$2;$3;$4;$5;$6)  `Work on International version  `PB de pile If (False)  ` ----------------------------------------------------  ` Nom utilisateur (OS) : Marc Duc-Jacquet  ` Date et heure : 18/11/08, 15:46:00  ` ------------------------------------------------------  ` ---------------   F R A N C A I S  ---------------  ` ------------------------------------------------------  ` Méthode : MATH_Orthodromie_Vincenty  ` Description  ` Adaptation à 4D de la méthode décrite par Vincenty  `  Voir   http://www.movable-type.co.uk/scripts/latlong-vincenty.html  ` Paramètres: $1 (lat1), $2 (lon1), $3 (lat2), $4 (lon2)  en degrés décimaux  ` en sortie: $5-> (distance en mètres), $6-> (cap initial) , $7-> (cap final)  ` ----------------------------------------------------  ` paramètres ellipsoïde WGS-84  ` ------------------------------------------------------  ` ---------------   E N G L I S H   -----------------  ` ------------------------------------------------------  ` Method : MATH_Orthodromie_Vincenty  ` Description  ` Adaptation for 4D of method described by Vincenty  ` See   http://www.movable-type.co.uk/scripts/latlong-vincenty.html  ` Parameters : $1 (lat1), $2 (lon1), $3 (lat2), $4 (lon2)  in sexagesimal degrees  ` Return parameters: $5-> (distance in meters), $6-> (initial heading) , $7-> (final heading)  ` ----------------------------------------------------  ` Ellipsoïd parameters WGS-84  ` ---------------------------------------------   `  (translation : BE 03-2010)End if C_REAL($1;$2;$3;$4)C_POINTER($5;$6;$7)$alfa:=6378137$beta:=6356752,3142$f:=1/298,257223563$L:=($4-$2)*Pi /180$U1:=Arctan((1-$f)*Tan($1*Pi /180))$U2:=Arctan((1-$f)*Tan($3*Pi /180))$sinU1:=Sin($U1)$cosU1:=Cos($U1)$sinU2:=Sin($U2)$cosU2:=Cos($U2)$iterLimit:=20$lambda:=$L$lambdaP:=$L$0:=0Repeat $sinlambda:=Sin($lambda)$coslambda:=Cos($lambda)$xx:=($cosU2*$sinlambda)*($cosU2*$sinlambda)$yy:=($cosU1*$sinU2)-($sinU1*$cosU2*$coslambda)$zz:=($cosU1*$sinU2)-($sinU1*$cosU2*$coslambda)$uu:=$yy*$zz$sinSigma:=Square root($xx+$uu)If ($sinSigma=0)$iterLimit:=1Else $cosSigma:=$sinU1*$sinU2+($cosU1*$cosU2*$coslambda)$sigma:=MATH_ArcTangente2 ($sinSigma;$cosSigma)$sinAlpha:=$cosU1*$cosU2*$sinlambda/$sinSigma$cosSqAlpha:=1-($sinAlpha*$sinAlpha)If ($cosSqAlpha=0)$cos2SigmaM:=0Else $cos2SigmaM:=$cosSigma-(2*$sinU1*$sinU2/$cosSqAlpha)End if $C:=$f/16*$cosSqAlpha*(4+($f*(4-(3*$cosSqAlpha))))$lambdaP:=$lambda$lambda:=$L+((1-$C)*$f*$sinAlpha*($sigma+($C*$sinSigma*(($cos2SigmaM)+($C*$cosSigma)*(-1+(2*$cos2SigmaM*$cos2SigmaM))))))End if $iterLimit:=$iterLimit-1Until ((Abs($lambda-$lambdap)*1000000000000<1) | ($iterLimit=0))If ($iterLimit=0)$0:=-1  `  pas de convergenceElse $uSq:=$cosSqAlpha*($alfa*$alfa-($beta*$beta))/($beta*$beta)$A:=1+($uSq/16384*(4096+($uSq*(-768+($uSq*(320-(175*$uSq)))))))$B:=$uSq/1024*(256+($uSq*(-128+($uSq*(74-(47*$uSq))))))$deltaSigma1:=-3+(4*$cos2SigmaM*$cos2SigmaM)$deltaSigma2:=-3+(4*$sinSigma*$sinSigma)$deltaSigma3:=$B/6*$cos2SigmaM*$deltaSigma2*$deltaSigma1$deltaSigma4:=-1+(2*$cos2SigmaM*$cos2SigmaM)$deltaSigma5:=$B/4*($cosSigma*$deltaSigma4-$deltaSigma3)$deltaSigma:=$B*$sinSigma*($cos2SigmaM+$deltaSigma5)$s:=$beta*$A*($sigma-$deltaSigma)$5->:=Round($s;3)  ` round to 1mm precision$6->:=MATH_ArcTangente2 ($cosU2*Sin($lambda);$cosU1*$sinU2-($sinU1*$cosU2*Cos($lambda)))*180/Pi   `cap initial$7->:=MATH_ArcTangente2 ($cosU1*Sin($lambda);(-$sinU1*$cosU2+($cosU1*$sinU2*Cos($lambda))))*180/Pi   `cap finalEnd if   `End if 