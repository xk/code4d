  `This method is part from Math4D project 2002-2010 with authors : Jacques Bossy, Philip Burns, Olivier Deschanels, Marc Duc-Jacquet  `Bernard Escaich, Antoine Galmiche, Micaël Germann, George F. Huhn, Nicolas Jore, Teddy Linet, Frédéric Quoirez, Michel Saiz, Robert Van Loo  If (False)  `XMTH_GMY_InsidePolygon (was MATH_PointInterieurPolygone)  `Auteur : Bernard ESCAICH  `Date : 06/2/2007  ` ------------------------------------------------------  ` ---------------   E N G L I S H   -----------------  ` ------------------------------------------------------  ` MATH_PointInterieurPolygone (PointerX;PointerY;X;Y) -> Result  ` PointerX (Pointer) Pointer to real array for abscissas  ` PointerY (Pointer) Pointer to real array for ordinates  ` X (Real) Abscissa of tested point  ` Y (Real) Ordoninate of tested point  ` Result (Boolean) True = tested point is inside polygone, else false.  ` ---------------------------------------------  `Scan segments  `Determine if point is under segment  `Memorize number of occurences  ` ---------------------------------------------  ` MATHERROR  `  0 -> No error  ` -1 -> Arrays empty or of different lenght  ` ------------------------------------------------------  ` ---------------   F R A N C A I S  ---------------  ` ------------------------------------------------------  ` MATH_PointInterieurPolygone (PointeurX;PointeurY;X;Y) -> Résultat  ` PointeurX (Pointeur) Pointeur vers tableau réel des abscisses  ` PointeurY (Pointeur) Pointeur vers tableau réel des ordonnées  ` X (Réel) Abscisse du point à test  ` Y (Réel) Ordonnée du point à tester  ` Résultat (Booléen) Vrai = le point est dans le polygone, Faux sinon.  ` ---------------------------------------------  `Balayer les segments  `Déterminer si le point est sous le segment   `Mémoriser le nombre d'occurences  ` ---------------------------------------------  ` MATHERROR  ` 0 -> Pas d'erreur  ` -1 -> Tableaux vides ou de tailles différentes  ` ---------------------------------------------  `  (translation : BE 03-2010)  `A ajouter dans les exemplesEnd if C_LONGINT(MATHERROR)C_POINTER($1;$2)  ` tableaux réels de coordonnéesC_REAL($3;$4)  ` coordonnées du pointC_BOOLEAN($0)C_LONGINT($vl_Sous_segment;$i)C_REAL($Y2)$0:=FalseIf (False)C_BOOLEAN(XMTH_GMY_InsidePolygon ;$0)C_POINTER(XMTH_GMY_InsidePolygon ;$1)C_POINTER(XMTH_GMY_InsidePolygon ;$2)C_REAL(XMTH_GMY_InsidePolygon ;$3)C_REAL(XMTH_GMY_InsidePolygon ;$4)End if   ` Traitement des erreursIf ((Size of array($1->)>0) & (Size of array($1->)=Size of array($2->)))MATHERROR:=0Else MATHERROR:=-1End if If (MATHERROR=0)For ($i;0;Size of array($1->)-1)If (($1->{$i}<=$3) & ($3<=$1->{$i+1})) | (($1->{$i}>=$3) & ($3>=$1->{$i+1}))  `Segment encadrant au dessus ou en dessousIf ($4>=$2->{$i}) & ($4>=$2->{$i+1})$vl_Sous_segment:=$vl_Sous_segment+1Else $Y2:=$2->{$i}+(($3-$1->{$i})*($2->{$i+1}-$2->{$i})/($1->{$i+1}-$1->{$i}))If ($Y2<=$4)$vl_Sous_segment:=$vl_Sous_segment+1End if End if End if End for If ($vl_Sous_segment#0) & (Mod($vl_Sous_segment;2)=1)$0:=TrueElse $0:=FalseEnd if End if 