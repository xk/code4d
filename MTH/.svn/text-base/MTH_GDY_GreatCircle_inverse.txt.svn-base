  `This method is part from Math4D project 2002-2010 with authors : Jacques Bossy, Philip Burns, Olivier Deschanels, Marc Duc-Jacquet  `Bernard Escaich, Antoine Galmiche, Micaël Germann, George F. Huhn, Nicolas Jore, Teddy Linet, Frédéric Quoirez, Michel Saiz, Robert Van LooIf (False)  `MTH_GDY_GreatCircle_inverse ` ----------------------------------------------------  ` Nom utilisateur (OS) : Marc Duc-Jacquet  ` Date et heure : 18/11/08, 15:46:00  ` ------------------------------------------------------  ` ---------------   E N G L I S H   -----------------  ` ------------------------------------------------------  ` Method : MATH_Orthodromie_Direct_Vincenty  ` Description  ` Adaptation for 4D of method described by Vincenty  ` See   http://www.movable-type.co.uk/scripts/latlong-vincenty.html  ` Parameters : $lat1, $lon1, lat2, lon2 in sexagesimal degrees  ` Return parameters: $5 (latitude), $6 (longitude) pointers  ` ------------------------------------------------------  ` ---------------   F R A N C A I S  ---------------  ` ------------------------------------------------------  ` Méthode : MATH_Orthodromie_Direct_Vincenty  ` Description  ` Adaptation à 4D de la méthode décrite par Vincenty  `  Voir   http://www.movable-type.co.uk/scripts/latlong-vincenty.html  ` Paramètres: $lat1, $lon1, lat2, lon2 en degrés décimaux données  ` Retour: $5 (latitude), $6 (longitude) pointeurs  ` ---------------------------------------------   `  (translation : BE 03-2010)End if $lat1:=$1$lon1:=$2$brng:=$3$dist:=$4C_REAL($sigma;$sigmaP;u)SET REAL COMPARISON LEVEL(0,0000000000001)If (False)C_LONGINT(MTH_GDY_GreatCircle_inverse ;$1)C_LONGINT(MTH_GDY_GreatCircle_inverse ;$2)C_LONGINT(MTH_GDY_GreatCircle_inverse ;$3)C_LONGINT(MTH_GDY_GreatCircle_inverse ;$4)C_POINTER(MTH_GDY_GreatCircle_inverse ;$5)C_POINTER(MTH_GDY_GreatCircle_inverse ;$6)C_POINTER(MTH_GDY_GreatCircle_inverse ;$7)End if $a:=6378137$b:=6356752,3142$f:=1/298,257223563  ` WGS-84$s:=$dist$alpha1:=$brng*Pi /180$sinAlpha1:=Sin($alpha1)$cosAlpha1:=Cos($alpha1)$tanU1:=(1-$f)*Tan($lat1*Pi /180)$cosU1:=1/Square root((1+($tanU1*$tanU1)))$sinU1:=$tanU1*$cosU1$sigma1:=MATH_ArcTangente2 ($tanU1;$cosAlpha1)$sinAlpha:=$cosU1*$sinAlpha1$cosSqAlpha:=1-($sinAlpha*$sinAlpha)$uSq:=$cosSqAlpha*($a*$a-($b*$b))/($b*$b)$ga:=(((-175*$uSq+320)*$uSq-768)*$uSq+4096)*$uSq/16384+1$gb:=(((-47*$uSq+74)*$uSq-128)*$uSq+256)*$uSq/1024$sigma:=$s/($b*$ga)$sigmaP:=2*Pi $u:=Abs($sigma-$sigmaP)While ($u>=0,000000000001)$cos2SigmaM:=Cos(2*$sigma1+$sigma)$sinSigma:=Sin($sigma)$cosSigma:=Cos($sigma)$x:=4*$cos2SigmaM*$cos2SigmaM-3$y:=4*$sinSigma*$sinSigma-3$z:=$gb/6*$cos2SigmaM*$y*$x$t:=$cosSigma*(2*$cos2SigmaM*$cos2SigmaM-1)$deltaSigma:=($gb/4*($t-$z)+$cos2SigmaM)*$gb*$sinSigma$sigmaP:=$sigma$sigma:=$s/($b*$ga)+$deltaSigma$u:=Abs($sigma-$sigmaP)End while $tmp:=$sinU1*$sinSigma-($cosU1*$cosSigma*$cosAlpha1)$lat2:=MATH_ArcTangente2 (($sinU1*$cosSigma)+($cosU1*$sinSigma*$cosAlpha1);(1-$f)*Square root($sinAlpha*$sinAlpha+($tmp*$tmp)))$lambda:=MATH_ArcTangente2 ($sinSigma*$sinAlpha1;$cosU1*$cosSigma-($sinU1*$sinSigma*$cosAlpha1))$C:=((-3*$cosSqAlpha+4)*$f+4)*$f/16*$cosSqAlpha$L:=$lambda-((((2*$cos2SigmaM*$cos2SigmaM-1)*$cosSigma*$C+$cos2SigmaM)*$sinSigma*$C+$sigma)*(1-$C)*$f*$sinAlpha)$5->:=$lat2*180/Pi $6->:=$lon1+($L*180/Pi )